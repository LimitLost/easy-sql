mod builtin_functions;
mod macros;
mod macros_components;
mod query_macro_components;
mod sql_convenience_attr;
mod sql_function;

mod derive;

use ::{proc_macro2, quote::quote};
use easy_macros::{always_context, anyhow_result, find_crate_list};
use proc_macro::TokenStream;

/// Prefix for aliases generated by #[sql(select = ...)] to avoid conflicts with table columns
const CUSTOM_SELECT_ALIAS_PREFIX: &str = "__easy_sql_custom_select_";

fn sql_crate() -> proc_macro2::TokenStream {
    if let Some(found) = find_crate_list(&[("easy-sql", quote! {})]) {
        found
    } else {
        quote! {self}
    }
}

/// Type-safe query! macro for executing SQL queries.
///
/// # Usage
///
/// ## SELECT Query
/// ```rust
/// // Basic SELECT
/// let result = query!(&mut conn, SELECT OutputType FROM TableType WHERE id = {user_id}).await?;
///
/// // With ORDER BY and LIMIT
/// let results = query!(&mut conn, SELECT OutputType FROM TableType WHERE status = "active" ORDER BY created_at DESC LIMIT 10).await?;
/// ```
///
/// ## INSERT Query
/// ```rust
/// // INSERT without RETURNING
/// query!(&mut conn, INSERT INTO TableType VALUES {data}).await?;
///
/// // INSERT with RETURNING
/// let inserted = query!(&mut conn, INSERT INTO TableType VALUES {data} RETURNING OutputType).await?;
/// ```
///
/// ## UPDATE Query
/// ```rust
/// // UPDATE without RETURNING
/// query!(&mut conn, UPDATE TableType SET field = {new_value} WHERE id = {user_id}).await?;
///
/// // UPDATE with RETURNING
/// let updated = query!(&mut conn, UPDATE TableType SET field = {new_value} WHERE id = {user_id} RETURNING OutputType).await?;
/// ```
///
/// ## DELETE Query
/// ```rust
/// // DELETE without RETURNING
/// query!(&mut conn, DELETE FROM TableType WHERE id = {user_id}).await?;
///
/// // DELETE with RETURNING
/// let deleted = query!(&mut conn, DELETE FROM TableType WHERE id = {user_id} RETURNING OutputType).await?;
/// ```
///
/// ## EXISTS Query
/// ```rust
/// // Check if records exist
/// let exists: bool = query!(&mut conn, EXISTS TableType WHERE email = {user_email}).await?;
/// ```
///
/// # Type Safety
/// All field names and types are validated at compile-time. The macro generates proper
/// parameter binding and SQL construction code.
///
/// TODO Note that `*conn` syntax might be needed when using `&mut EasyExecutor<D>` as connection
#[proc_macro]
#[always_context]
#[anyhow_result]
pub fn query(item: TokenStream) -> anyhow::Result<TokenStream> {
    macros::query(item)
}

#[always_context]
/// Debug version of `query!` that prints the generated code and panics.
/// Useful for inspecting macro expansion during development.
#[proc_macro]
#[anyhow_result]
#[no_context]
pub fn query_debug(item: TokenStream) -> anyhow::Result<TokenStream> {
    let result = macros::query(item)?;
    panic!("{}", result);
}

/// Documentation WIP
/// - Takes same input as query! macro
/// - `.await?` is required
/// - Returns a value implementing `fetch(conn)` function
///    - taking `impl sqlx::Executor` as an argument,
///    - returning `futures::Stream<Item = anyhow::Result<Output>>`
/// - Selected Query needs to returning a value (use SELECT or RETURNING clause, EXISTS is not supported)
#[proc_macro]
#[always_context]
#[anyhow_result]
pub fn query_lazy(item: TokenStream) -> anyhow::Result<TokenStream> {
    macros::query_lazy(item)
}

#[always_context]
/// Debug version of `query_lazy!` that prints the generated code and panics.
/// Useful for inspecting macro expansion during development.
#[proc_macro]
#[anyhow_result]
#[no_context]
pub fn query_lazy_debug(item: TokenStream) -> anyhow::Result<TokenStream> {
    let result = macros::query_lazy(item)?;
    panic!("{}", result);
}

#[always_context]
#[proc_macro]
#[anyhow_result]
pub fn table_join(item: TokenStream) -> anyhow::Result<TokenStream> {
    macros::table_join(item)
}

#[always_context]
#[proc_macro]
#[anyhow_result]
#[no_context]
pub fn table_join_debug(item: TokenStream) -> anyhow::Result<TokenStream> {
    let result = macros::table_join(item)?;
    panic!("{}", result);
}

#[always_context]
#[proc_macro_derive(DatabaseSetup)]
#[anyhow_result]
pub fn database_setup(item: TokenStream) -> anyhow::Result<TokenStream> {
    derive::database_setup(item)
}

#[always_context]
#[proc_macro_derive(Output, attributes(sql))]
#[anyhow_result]
pub fn output(item: TokenStream) -> anyhow::Result<TokenStream> {
    derive::output(item)
}

#[always_context]
#[proc_macro_derive(OutputDebug, attributes(sql))]
#[anyhow_result]
#[no_context]
pub fn output_debug(item: TokenStream) -> anyhow::Result<TokenStream> {
    let output = derive::output(item)?;

    panic!("{}", output);
}

#[always_context]
#[proc_macro_derive(Insert, attributes(sql))]
#[anyhow_result]
pub fn insert(item: TokenStream) -> anyhow::Result<TokenStream> {
    derive::insert(item)
}

#[always_context]
#[proc_macro_derive(InsertDebug, attributes(sql))]
#[anyhow_result]
#[no_context]
pub fn insert_debug(item: TokenStream) -> anyhow::Result<TokenStream> {
    let output = derive::insert(item)?;

    panic!("{}", output);
}

#[always_context]
#[proc_macro_derive(Update, attributes(sql))]
#[anyhow_result]
pub fn sql_update(item: TokenStream) -> anyhow::Result<TokenStream> {
    derive::update(item)
}

#[always_context]
#[proc_macro_derive(UpdateDebug, attributes(sql))]
#[anyhow_result]
#[no_context]
pub fn sql_update_debug(item: TokenStream) -> anyhow::Result<TokenStream> {
    let output = derive::update(item)?;

    panic!("{}", output);
}

#[always_context]
#[proc_macro_derive(Table, attributes(sql))]
#[anyhow_result]
pub fn table(item: TokenStream) -> anyhow::Result<TokenStream> {
    derive::table(item)
}

#[always_context]
#[proc_macro_derive(TableDebug, attributes(sql))]
#[anyhow_result]
#[no_context]
pub fn table_debug(item: TokenStream) -> anyhow::Result<TokenStream> {
    let output = derive::table(item)?;

    panic!("{}", output);
}

#[always_context]
#[proc_macro_attribute]
#[anyhow_result]
pub fn sql_convenience(attr: TokenStream, item: TokenStream) -> anyhow::Result<TokenStream> {
    sql_convenience_attr::sql_convenience(attr, item)
}

/// Define a custom SQL function that can be used in query! macros.
///
/// # Syntax
/// ```rust
/// custom_sql_function!(FunctionName; "SQL_FUNCTION_NAME"; 1 | 2 | Any);
/// ```
///
/// # Arguments
/// - `FunctionName`: The Rust struct name for the function
/// - `"SQL_FUNCTION_NAME"`: The SQL function name emitted in queries
/// - `args`: Argument count specification:
///   - A number (e.g., `2`) for exact argument count
///   - Multiple numbers separated by `|` (e.g., `1 | 2`) for multiple allowed counts
///   - `Any` for any number of arguments
///
/// # Examples
/// ```rust
/// // Exact argument count
/// custom_sql_function!(JsonExtract; "JSON_EXTRACT"; 2);
///
/// // Multiple allowed counts
/// custom_sql_function!(Slice; "SUBSTR"; 2 | 3);
///
/// // Any number of arguments
/// custom_sql_function!(Coalesce_Any; "COALESCE"; Any);
///
/// // Usage in query: (Any case can be used)
/// query!(&mut conn, SELECT * FROM Table WHERE JsonExtract(data, "$.field") = "value")
/// query!(&mut conn, SELECT * FROM Table WHERE slice(name, 2, 3) = "ell")
/// query!(&mut conn, SELECT * FROM Table WHERE coalesce_Any(name, "fallback") = "value")
/// ```
#[proc_macro]
#[always_context]
#[anyhow_result]
pub fn custom_sql_function(input: TokenStream) -> anyhow::Result<TokenStream> {
    Ok(sql_function::custom_sql_function_impl(input))
}
