use convert_case::{Case, Casing};
use easy_macros::{
    anyhow::{self, Context},
    helpers::parse_macro_input,
    macros::always_context,
    quote::{ToTokens, quote},
    syn,
};

use crate::sql_derive::{sql_insert_base, sql_output_base, sql_update_base};

#[always_context]
pub fn sql_table(item: proc_macro::TokenStream) -> anyhow::Result<proc_macro::TokenStream> {
    let item = parse_macro_input!(item as syn::ItemStruct);
    let item_name = &item.ident;
    let item_name_tokens = item.ident.to_token_stream();

    let fields = match item.fields {
        syn::Fields::Named(fields_named) => fields_named.named,
        syn::Fields::Unnamed(_) => {
            anyhow::bail!("Unnamed struct fields are not supported")
        }
        syn::Fields::Unit => anyhow::bail!("Unit struct is not supported"),
    };
    let field_names_str = fields.iter().map(|field| field.ident.as_ref().unwrap().to_string());

    let table_name = item_name.to_string().to_case(Case::Snake);

    let insert_impl = sql_insert_base(
        &item_name,
        &fields,
        &item_name_tokens,
        vec![] as Vec<syn::Ident>,
    )?;
    let update_impl = sql_update_base(&item_name, &fields, &item_name_tokens)?;
    let output_impl = sql_output_base(&item_name, &fields, &item_name_tokens);

    let mut is_primary_key=Vec::new();
    let mut is_unique=Vec::new();
    let mut primary_key_found=false;
    let mut field_types = Vec::new();
    let mut is_not_null=Vec::new();

    for field in fields.iter(){
        let (variant,is_field_not_null) = ty_enum_value(&field.ty)?;
        is_not_null.push(is_field_not_null);
        if let Some(variant) = variant{
            field_types.push(variant);
        }else{
            let current_is_primary_key=has_attribute!(field, #[sql(primary_key)]);
            if current_is_primary_key{
                if !primary_key_found {
                    primary_key_found=true;
                    is_primary_key.push(true);
                }else{
                    anyhow::bail!("Only one primary key is allowed per table!.");
                }
            }else{
                is_primary_key.push(false);
            }
            is_unique.push(has_attribute!(field, #[sql(unique)]));
            
            if has_attribute!(field, #[sql(bytes)]){
                field_types.push(quote! {Bytes});
            }else{
                anyhow::bail!("Field type {:?} is not supported, use #[sql(bytes)] to convert it into bytes", field.ty);
            }
        }
    }

    let table_version=TODO;

    Ok(quote! {
        impl easy_lib::sql::DatabaseSetup for #item_name {
            async fn setup(
                conn: &mut (impl crate::EasyExecutor + Send + Sync),
                used_table_names: &mut Vec<String>,
            ) -> easy_lib::anyhow::Result<()> {
                use crate::EasyExecutor;
                use easy_lib::anyhow::Context;

                let table_exists = conn.query_setup(easy_lib::sql::TableExists{name: #table_name}).with_context(easy_sql::macros::context!("Checking if table exists: {:?}".#table_name)).await?;

                if table_exists{
                    //TODO Get Table Version and migrate (alter table + update version) if neccessary
                }else{
                    // Create table and create version in EasySqlTables
                    conn.query_setup(CreateTable{table_name: EasySqlTables::table_name(), fields: vec![
                        #(TableField{name: #field_names_str, data_type: easy_lib::sql::SqlType::#field_types, is_primary_key: #is_primary_key, foreign_key: None, is_unique: #is_unique, is_not_null: #is_not_null},)*
                    ]}).await?;
                    easy_lib::sql::EasySqlTables::create(conn, #table_name.to_string(), #table_version).await?;


                }

                //If table doesn't exist ( https://stackoverflow.com/questions/1601151/how-do-i-check-in-sqlite-whether-a-table-exists )
                //Save current version to easy_sql_tables table

                //Create Unique id for every table (saved inside of macro file before compilation)
                //Every Unique id is generated by the build.rs
                //Check for table removal inside of build script

                //Create migrations based on table number change
                //Check if default value was provided by user (if field is not Option<>)

                //TODO In procedural macro
                // save table fields into a file (when the version number attribute changed)

                //In sqlite you can only add new columns and rename old ones
                //(without recreating a table https://www.sqlitetutorial.net/sqlite-alter-table/ )

                Ok(())
            }
        }

        impl easy_lib::sql::SqlTable for #item_name {
            fn table_name() -> &'static str {
                #table_name
            }
        }

        impl easy_lib::sql::HasTable<#item_name> for #item_name{}

        #insert_impl
        #update_impl
        #output_impl
    }.into())
}
