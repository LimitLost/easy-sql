

#[always_context]
pub fn sql_table(item: proc_macro::TokenStream) -> anyhow::Result<proc_macro::TokenStream> {
    let item = parse_macro_input!(item as syn::ItemStruct);
    let item_name = &item.ident;

    let fields = match item.fields {
        syn::Fields::Named(fields_named) => fields_named.named,
        syn::Fields::Unnamed(_) => {
            anyhow::bail!("Unnamed struct fields are not supported")
        }
        syn::Fields::Unit => anyhow::bail!("Unit struct is not supported"),
    };


    let table_name=item_name.to_string().to_case(Case::Snake);

    let insert_impl=sql_insert_base(&item_name,&fields,&item_name, vec![]);
    let update_impl=sql_update_base(&item_name,&fields,&item_name);
    let output_impl=sql_output_base(&item_name,&fields,&item_name);

    quote!{
        impl easy_lib::sql::DatabaseSetup for #item_name {
            async fn setup(
                conn: &mut (impl crate::EasyExecutor + Send + Sync),
                used_table_names: &mut Vec<String>,
            ) -> easy_lib::anyhow::Result<()> {
                use crate::EasyExecutor;
                use easy_lib::anyhow::Context;

                let table_exists = conn.query_setup(easy_lib::sql::TableExists{name: #table_name}).with_context(easy_sql::macros::context!("Checking if table exists: {:?}".#table_name))?;
        
                if table_exists{
                    //TODO Get Table Version and migrate (alter table + update version) if neccessary
                }else{
                    //TODO Create table and update version


                }

                //If table doesn't exist ( https://stackoverflow.com/questions/1601151/how-do-i-check-in-sqlite-whether-a-table-exists )
                //Save current version to easy_sql_tables table
        
                //Create Unique id for every table (saved inside of macro file before compilation)
                //Every Unique id is generated by the build.rs
                //Check for table removal inside of build script
        
                //Create migrations based on table number change
                //Check if default value was provided by user (if field is not Option<>)
        
                //TODO In procedural macro
                // save table fields into a file (when the version number attribute changed)
        
                //In sqlite you can only add new columns and rename old ones
                //(without recreating a table https://www.sqlitetutorial.net/sqlite-alter-table/ )
        
                Ok(())
            }
        }

        impl easy_lib::sql::SqlTable for #item_name {
            fn table_name() -> &'static str {
                #table_name
            }
        }

        impl easy_lib::sql::HasTable<#item_name> for #item_name{}

        #insert_impl
        #update_impl
        #output_impl
    }
}