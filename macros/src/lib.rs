mod macros;
mod macros_components;

mod derive;
mod derive_components;

use ::{proc_macro2, quote::quote};
use easy_macros::{always_context, anyhow_result, find_crate_list};
use proc_macro::TokenStream;

/// Prefix for aliases generated by #[sql(select = ...)] to avoid conflicts with table columns
const CUSTOM_SELECT_ALIAS_PREFIX: &str = "__easy_sql_custom_select_";

fn sql_crate() -> proc_macro2::TokenStream {
    if let Some(found) = find_crate_list(&[("easy-sql", quote! {})]) {
        found
    } else {
        quote! {self}
    }
}

#[proc_macro]
#[always_context]
#[anyhow_result]
pub fn query(item: TokenStream) -> anyhow::Result<TokenStream> {
    macros::query(item)
}

#[always_context]
/// Debug version of `query!` that prints the generated code and panics.
/// Useful for inspecting macro expansion during development.
#[proc_macro]
#[anyhow_result]
#[no_context]
pub fn query_debug(item: TokenStream) -> anyhow::Result<TokenStream> {
    let result = macros::query(item)?;
    panic!("{}", result);
}

#[proc_macro]
#[always_context]
#[anyhow_result]
pub fn query_lazy(item: TokenStream) -> anyhow::Result<TokenStream> {
    macros::query_lazy(item)
}

#[always_context]
/// Debug version of `query_lazy!` that prints the generated code and panics.
/// Useful for inspecting macro expansion during development.
#[proc_macro]
#[anyhow_result]
#[no_context]
pub fn query_lazy_debug(item: TokenStream) -> anyhow::Result<TokenStream> {
    let result = macros::query_lazy(item)?;
    panic!("{}", result);
}

#[always_context]
#[proc_macro]
#[anyhow_result]
pub fn table_join(item: TokenStream) -> anyhow::Result<TokenStream> {
    macros::table_join(item)
}

#[always_context]
#[proc_macro]
#[anyhow_result]
#[no_context]
pub fn table_join_debug(item: TokenStream) -> anyhow::Result<TokenStream> {
    let result = macros::table_join(item)?;
    panic!("{}", result);
}

#[always_context]
#[proc_macro_derive(DatabaseSetup, attributes(sql))]
#[anyhow_result]
pub fn database_setup(item: TokenStream) -> anyhow::Result<TokenStream> {
    derive::database_setup(item)
}

#[always_context]
#[proc_macro_derive(Output, attributes(sql))]
#[anyhow_result]
pub fn output(item: TokenStream) -> anyhow::Result<TokenStream> {
    derive::output(item)
}

#[always_context]
#[proc_macro_derive(OutputDebug, attributes(sql))]
#[anyhow_result]
#[no_context]
pub fn output_debug(item: TokenStream) -> anyhow::Result<TokenStream> {
    let output = derive::output(item)?;

    panic!("{}", output);
}

#[always_context]
#[proc_macro_derive(Insert, attributes(sql))]
#[anyhow_result]
pub fn insert(item: TokenStream) -> anyhow::Result<TokenStream> {
    derive::insert(item)
}

#[always_context]
#[proc_macro_derive(InsertDebug, attributes(sql))]
#[anyhow_result]
#[no_context]
pub fn insert_debug(item: TokenStream) -> anyhow::Result<TokenStream> {
    let output = derive::insert(item)?;

    panic!("{}", output);
}

#[always_context]
#[proc_macro_derive(Update, attributes(sql))]
#[anyhow_result]
pub fn sql_update(item: TokenStream) -> anyhow::Result<TokenStream> {
    derive::update(item)
}

#[always_context]
#[proc_macro_derive(UpdateDebug, attributes(sql))]
#[anyhow_result]
#[no_context]
pub fn sql_update_debug(item: TokenStream) -> anyhow::Result<TokenStream> {
    let output = derive::update(item)?;

    panic!("{}", output);
}

#[always_context]
#[proc_macro_derive(Table, attributes(sql))]
#[anyhow_result]
pub fn table(item: TokenStream) -> anyhow::Result<TokenStream> {
    derive::table(item)
}

#[always_context]
#[proc_macro_derive(TableDebug, attributes(sql))]
#[anyhow_result]
#[no_context]
pub fn table_debug(item: TokenStream) -> anyhow::Result<TokenStream> {
    let output = derive::table(item)?;

    panic!("{}", output);
}

#[proc_macro]
#[always_context]
#[anyhow_result]
pub fn custom_sql_function(input: TokenStream) -> anyhow::Result<TokenStream> {
    Ok(macros::custom_sql_function_impl(input))
}

#[proc_macro]
#[always_context]
#[anyhow_result]
pub fn impl_supports_fn_any(input: TokenStream) -> anyhow::Result<TokenStream> {
    macros::impl_supports_fn_any(input)
}

#[proc_macro]
#[always_context]
#[anyhow_result]
pub fn impl_supports_fn(input: TokenStream) -> anyhow::Result<TokenStream> {
    macros::impl_supports_fn(input)
}

#[proc_macro]
#[always_context]
#[anyhow_result]
pub fn define_supports_fn_trait(input: TokenStream) -> anyhow::Result<TokenStream> {
    macros::define_supports_fn_trait(input)
}

#[proc_macro]
#[always_context]
#[anyhow_result]
pub fn define_supports_operator_trait(input: TokenStream) -> anyhow::Result<TokenStream> {
    macros::define_supports_operator_trait(input)
}
