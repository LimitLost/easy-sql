use std::collections::HashMap;

use easy_macros::{
    anyhow::{self, Context},
    helpers::MacroResult,
    macros::{always_context, get_attributes, has_attributes},
    proc_macro2::TokenStream,
    quote::ToTokens,
    syn,
};
use serde::{Deserialize, Serialize};

use crate::SqlType;

#[derive(Debug, Serialize, Deserialize)]
pub struct TableField {
    pub name: String,
    pub sql_type: super::sql_type::SqlType,
    ///Tokens converted to_string()
    pub default: Option<String>,
    pub is_not_null: bool,
    pub is_unique: bool,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TableDataVersion {
    pub table_name: String,
    pub fields: Vec<TableField>,
    pub primary_keys: Vec<String>,
    ///0 - key, 1 - table (struct) name
    pub foreign_keys: Vec<(String, String)>,
}

impl TableDataVersion {
    pub fn from_struct(item: &syn::ItemStruct, table_name: String) -> anyhow::Result<Self> {
        let fields = match &item.fields {
            syn::Fields::Named(fields_named) => &fields_named.named,
            _ => {
                anyhow::bail!(
                    "non named field type should be handled before `generate_table_data_from_struct` is called"
                )
            }
        };

        let mut fields_converted = Vec::new();
        let mut primary_keys = Vec::new();
        let mut foreign_keys = Vec::new();

        for field in fields.iter() {
            let name = field.ident.as_ref().unwrap().to_string();

            let (sql_type, is_not_null) = SqlType::from_syn_type(&field.ty)?;

            let to_bytes = has_attributes!(field, #[sql(bytes)]);

            let sql_type = if to_bytes {
                SqlType::Bytes
            } else {
                match sql_type {
                    Some(o) => o,
                    None => {
                        anyhow::bail!(
                            "Field type `{}` is not supported, use #[sql(bytes)] to convert it into bytes",
                            field.ty.to_token_stream()
                        );
                    }
                }
            };

            let default = get_attributes!(field, #[sql(default = __unknown__)])
                .into_iter()
                .next()
                .map(|e| e.to_string());

            for foreign_key in get_attributes!(field, #[sql(foreign_key = __unknown__)])
                .into_iter()
                .map(|e| e.to_string())
            {
                foreign_keys.push((name.clone(), foreign_key));
            }

            if has_attributes!(field, #[sql(primary_key)]) {
                primary_keys.push(name.clone());
            }

            let is_unique = has_attributes!(field, #[sql(unique)]);

            fields_converted.push(TableField {
                name,
                sql_type: sql_type,
                default,
                is_not_null,
                is_unique,
            });
        }

        Ok(TableDataVersion {
            table_name,
            fields: fields_converted,
            foreign_keys,
            primary_keys,
        })
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TableData {
    pub saved_versions: HashMap<u64, TableDataVersion>,
    pub latest_version: u64,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct CompilationData {
    ///Key - table id, generated by build macro, put in #[sql(unique_id = "...")] attribute on struct
    pub tables: HashMap<String, TableData>,
}
#[always_context]
impl CompilationData {
    pub fn load() -> anyhow::Result<CompilationData> {
        let current_dir = std::env::current_dir()?;

        let data_path = current_dir.join("easy_sql.ron");

        let data: CompilationData = {
            #[cfg(feature = "build")]
            {
                if !data_path.exists() {
                    CompilationData {
                        tables: HashMap::new(),
                    }
                } else {
                    let data = std::fs::read_to_string(&data_path)
                        .context("Failed to read easy_sql.ron file")?;

                    ron::de::from_str(&data).context("Failed to parse easy_sql.ron file")?
                }
            }
            #[cfg(not(feature = "build"))]
            {
                if !data_path.exists() {
                    anyhow::bail!(
                        "`easy_lib::sql::build` in build script is required (for automatic migrations and checks); easy_sql.ron file not found in the project directory: {:?}",
                        current_dir
                    );
                }

                let data = std::fs::read_to_string(&data_path)
                    .context("Failed to read easy_sql.ron file")?;

                ron::de::from_str(&data).context("Failed to parse easy_sql.ron file")?
            }
        };

        Ok(data)
    }

    #[cfg(feature = "build")]
    pub fn save(&self) -> anyhow::Result<()> {
        let current_dir = std::env::current_dir()?;

        let data_path = current_dir.join("easy_sql.ron");

        let data =
            ron::ser::to_string_pretty(self, ron::ser::PrettyConfig::new().struct_names(true))?;

        std::fs::write(&data_path, &data).context("Failed to write easy_sql.ron file")?;

        Ok(())
    }

    pub fn generate_unique_id(&self) -> String {
        let mut generated = uuid::Uuid::new_v4().to_string();
        let mut exists = true;

        while exists {
            exists = false;
            for unique_id in self.tables.keys() {
                if unique_id == &generated {
                    exists = true;
                    generated = uuid::Uuid::new_v4().to_string();
                    break;
                }
            }
        }
        generated
    }

    pub fn is_duplicate_table_name(
        &self,
        current_unique_id: &str,
        table_name: &str,
    ) -> anyhow::Result<bool> {
        if table_name == "easy_sql_tables" {
            return Ok(true);
        }
        for (unique_id, table_data) in self.tables.iter() {
            if unique_id == current_unique_id {
                continue;
            }
            let latest_version_data =
                match table_data.saved_versions.get(&table_data.latest_version) {
                    Some(o) => o,
                    None => anyhow::bail!(
                        "Table data not found for latest version: {} | unique id: {:?}",
                        table_data.latest_version,
                        unique_id
                    ),
                };

            if latest_version_data.table_name == table_name {
                return Ok(true);
            }
        }

        Ok(false)
    }

    pub fn generate_migrations(
        &self,
        current_unique_id: &str,
        latest_version: &TableDataVersion,
        latest_version_number: u64,
    ) -> anyhow::Result<TokenStream> {
        let table_data = self
            .tables
            .get(current_unique_id)
            .context("Table not found in Sql Compilation Data (easy_sql.ron)")?;

        let mut result = MacroResult::default();

        for (version_number, version_data) in table_data.saved_versions.iter() {
            if version_number == &latest_version_number {
                continue;
            }
            //version_data.fields
        }

        todo!()
    }
}

//TODO Check for table removal inside of build script

//In sqlite you can only add new columns and rename old ones
//(without recreating a table https://www.sqlitetutorial.net/sqlite-alter-table/ )
