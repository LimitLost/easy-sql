use std::collections::HashMap;

use easy_macros::{
    anyhow::{self, Context},
    helpers::MacroResult,
    macros::{always_context, get_attributes, has_attributes},
    proc_macro2::TokenStream,
    quote::{ToTokens, quote},
    syn,
};
use serde::{Deserialize, Serialize};

use crate::SqlType;

#[derive(Debug, Serialize, Deserialize)]
pub struct TableField {
    pub name: String,
    pub sql_type: super::sql_type::SqlType,
    ///Tokens converted to_string()
    pub default: Option<String>,
    pub is_not_null: bool,
    pub is_unique: bool,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TableDataVersion {
    pub table_name: String,
    pub fields: Vec<TableField>,
    pub primary_keys: Vec<String>,
    pub auto_increment: bool,
    ///key - table (struct) name
    ///value - current field name
    pub foreign_keys: HashMap<String, Vec<String>>,
}

impl TableDataVersion {
    pub fn from_struct(item: &syn::ItemStruct, table_name: String) -> anyhow::Result<Self> {
        let fields = match &item.fields {
            syn::Fields::Named(fields_named) => &fields_named.named,
            _ => {
                anyhow::bail!(
                    "non named field type should be handled before `generate_table_data_from_struct` is called"
                )
            }
        };

        let mut fields_converted = Vec::new();
        let mut primary_keys = Vec::new();
        let mut foreign_keys = HashMap::new();

        let mut auto_increment = false;

        for field in fields.iter() {
            let name = field.ident.as_ref().unwrap().to_string();

            //Auto Increment Check
            if has_attributes!(field, #[sql(auto_increment)]) {
                if auto_increment {
                    anyhow::bail!("Auto increment is only supported for single primary key");
                }
                auto_increment = true;
            }

            let (sql_type, is_not_null) = SqlType::from_syn_type(&field.ty)?;

            let to_bytes = has_attributes!(field, #[sql(bytes)]);

            let sql_type = if to_bytes {
                SqlType::Bytes
            } else {
                match sql_type {
                    Some(o) => o,
                    None => {
                        anyhow::bail!(
                            "Field type `{}` is not supported, use #[sql(bytes)] to convert it into bytes",
                            field.ty.to_token_stream()
                        );
                    }
                }
            };

            let default = get_attributes!(field, #[sql(default = __unknown__)])
                .into_iter()
                .next()
                .map(|e| e.to_string());

            for foreign_key in get_attributes!(field, #[sql(foreign_key = __unknown__)])
                .into_iter()
                .map(|e| e.to_string())
            {
                let fields: &mut Vec<String> = foreign_keys
                    .entry(foreign_key)
                    .or_insert(Default::default());
                fields.push(name.clone());
            }

            if has_attributes!(field, #[sql(primary_key)]) {
                primary_keys.push(name.clone());
            }

            let is_unique = has_attributes!(field, #[sql(unique)]);

            fields_converted.push(TableField {
                name,
                sql_type: sql_type,
                default,
                is_not_null,
                is_unique,
            });
        }

        Ok(TableDataVersion {
            table_name,
            fields: fields_converted,
            foreign_keys,
            primary_keys,
            auto_increment,
        })
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TableData {
    pub saved_versions: HashMap<u64, TableDataVersion>,
    pub latest_version: u64,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct CompilationData {
    ///Key - table id, generated by build macro, put in #[sql(unique_id = "...")] attribute on struct
    pub tables: HashMap<String, TableData>,
}
#[always_context]
impl CompilationData {
    pub fn load() -> anyhow::Result<CompilationData> {
        let current_dir = std::env::current_dir()?;

        let data_path = current_dir.join("easy_sql.ron");

        let data: CompilationData = {
            #[cfg(feature = "build")]
            {
                if !data_path.exists() {
                    CompilationData {
                        tables: HashMap::new(),
                    }
                } else {
                    let data = std::fs::read_to_string(&data_path)
                        .context("Failed to read easy_sql.ron file")?;

                    ron::de::from_str(&data).context("Failed to parse easy_sql.ron file")?
                }
            }
            #[cfg(not(feature = "build"))]
            {
                if !data_path.exists() {
                    anyhow::bail!(
                        "`easy_lib::sql::build` in build script is required (for automatic migrations and checks); easy_sql.ron file not found in the project directory: {:?}",
                        current_dir
                    );
                }

                let data = std::fs::read_to_string(&data_path)
                    .context("Failed to read easy_sql.ron file")?;

                ron::de::from_str(&data).context("Failed to parse easy_sql.ron file")?
            }
        };

        Ok(data)
    }

    #[cfg(feature = "build")]
    pub fn save(&self) -> anyhow::Result<()> {
        let current_dir = std::env::current_dir()?;

        let data_path = current_dir.join("easy_sql.ron");

        let data =
            ron::ser::to_string_pretty(self, ron::ser::PrettyConfig::new().struct_names(true))?;

        std::fs::write(&data_path, &data).context("Failed to write easy_sql.ron file")?;

        Ok(())
    }

    pub fn generate_unique_id(&self) -> String {
        let mut generated = uuid::Uuid::new_v4().to_string();
        let mut exists = true;

        while exists {
            exists = false;
            for unique_id in self.tables.keys() {
                if unique_id == &generated {
                    exists = true;
                    generated = uuid::Uuid::new_v4().to_string();
                    break;
                }
            }
        }
        generated
    }

    pub fn is_duplicate_table_name(
        &self,
        current_unique_id: &str,
        table_name: &str,
    ) -> anyhow::Result<bool> {
        if table_name == "easy_sql_tables" {
            return Ok(true);
        }
        for (unique_id, table_data) in self.tables.iter() {
            if unique_id == current_unique_id {
                continue;
            }
            let latest_version_data =
                match table_data.saved_versions.get(&table_data.latest_version) {
                    Some(o) => o,
                    None => anyhow::bail!(
                        "Table data not found for latest version: {} | unique id: {:?}",
                        table_data.latest_version,
                        unique_id
                    ),
                };

            if latest_version_data.table_name == table_name {
                return Ok(true);
            }
        }

        Ok(false)
    }

    pub fn generate_migrations(
        &self,
        current_unique_id: &str,
        latest_version: &TableDataVersion,
        latest_version_number: u64,
        sql_crate: &TokenStream,
    ) -> anyhow::Result<TokenStream> {
        let table_data = self
            .tables
            .get(current_unique_id)
            .context("Table not found in Sql Compilation Data (easy_sql.ron)")?;

        let mut result = MacroResult::default();

        for (version_number, version_data) in table_data.saved_versions.iter() {
            let mut changes_needed = Vec::new();

            if version_number == &latest_version_number {
                continue;
            }
            //Primary Key Check (Must be equal)
            if version_data.primary_keys != latest_version.primary_keys {
                anyhow::bail!(
                    "Primary key change is not supported (yet) -> Latest Version: {:?} ||| Version {}: {:?}",
                    latest_version.primary_keys,
                    version_number,
                    version_data.primary_keys
                );
            }
            //Foreign Key Check (Must be equal)
            if version_data.foreign_keys != latest_version.foreign_keys {
                anyhow::bail!(
                    "Foreign key change is not supported (yet) -> Latest Version: {:?} ||| Version {}: {:?}",
                    latest_version.foreign_keys,
                    version_number,
                    version_data.foreign_keys
                );
            }
            //Auto increment check (Must be equal)
            if version_data.auto_increment != latest_version.auto_increment {
                anyhow::bail!(
                    "Auto increment change is not supported (yet) -> Latest Version: {:?} ||| Version {}: {:?}",
                    latest_version.auto_increment,
                    version_number,
                    version_data.auto_increment
                );
            }

            // Table name change support
            if version_data.table_name != latest_version.table_name {
                let new_name = latest_version.table_name.as_str();

                // Rename table
                changes_needed.push(quote! {
                    #sql_crate::AlterTableSingle::RenameTable{
                        new_table_name: #new_name,
                    }
                });
            }

            // Check for old column change
            for (old_field, new_field) in
                version_data.fields.iter().zip(latest_version.fields.iter())
            {
                //We can only rename old columns
                if old_field.name != new_field.name {
                    let old_name = old_field.name.as_str();
                    let new_name = new_field.name.as_str();

                    // Rename field
                    changes_needed.push(quote! {
                        #sql_crate::AlterTableSingle::RenameColumn{
                            old_column_name: #old_name,
                            new_column_name: #new_name,
                        }
                    });
                }
                //Everything else on old column is not supported
                if old_field.is_not_null != new_field.is_not_null {
                    anyhow::bail!(
                        "Field type change is not supported (yet) (only rename) -> Latest Version: {:?} ||| Version {}: {:?}",
                        latest_version.fields,
                        version_number,
                        version_data.fields
                    );
                }
                if old_field.sql_type != new_field.sql_type {
                    anyhow::bail!(
                        "Field type change is not supported (yet) (only rename) -> Latest Version: {:?} ||| Version {}: {:?}",
                        latest_version.fields,
                        version_number,
                        version_data.fields
                    );
                }
                if old_field.is_unique != new_field.is_unique {
                    anyhow::bail!(
                        "Field unique change is not supported (yet) (only rename) -> Latest Version: {:?} ||| Version {}: {:?}",
                        latest_version.fields,
                        version_number,
                        version_data.fields
                    );
                }
                if old_field.default != new_field.default {
                    anyhow::bail!(
                        "Field default value change is not supported (yet) (only rename) -> Latest Version: {:?} ||| Version {}: {:?}",
                        latest_version.fields,
                        version_number,
                        version_data.fields
                    );
                }
            }

            //New Columns Check
            for new_field in latest_version.fields.iter().skip(version_data.fields.len()) {
                //New columns need default value
                if new_field.default.is_none() && new_field.is_not_null {
                    anyhow::bail!(
                        "New (not null) column without default value is not supported -> Latest Version: {:?} ||| Version {}: {:?}",
                        latest_version.fields,
                        version_number,
                        version_data.fields
                    );
                }

                let field_name = new_field.name.as_str();
                let data_type = new_field.sql_type.to_tokens(sql_crate);
                let default_value = new_field.default.as_ref().map(|s| s.as_str());
                let is_not_null = new_field.is_not_null;
                let is_unique = new_field.is_unique;

                //Create new field
                changes_needed.push(quote! {
                    #sql_crate::AlterTableSingle::AddColumn{
                        column: #sql_crate::TableField {
                            name: #field_name,
                            data_type: #data_type,
                            is_unique: #is_unique,
                            is_not_null: #is_not_null,
                            default: Some(#default_value.to_string()),
                        }
                    }
                });
            }

            //Generate Migration (if needed)
            if !changes_needed.is_empty() {
                let version_number = *version_number;
                let table_name = latest_version.table_name.as_str();

                result.add(quote! {
                    if current_version_number == #version_number{
                        conn.query_setup(#sql_crate::AlterTable{
                            table_name: #table_name,
                            changes: vec![#(#changes_needed),*],
                        }).await?;
                        #sql_crate::EasySqlTables::update_version(conn, #table_name, #version_number).await?;
                        return Ok(());
                    }
                });
            }
        }

        Ok(result.finalize())
    }
}

//TODO Check for table removal inside of build script

//In sqlite you can only add new columns and rename old ones
//(without recreating a table https://www.sqlitetutorial.net/sqlite-alter-table/ )
