use std::collections::HashMap;

use easy_macros::{
    anyhow::{self, Context},
    macros::always_context,
};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct TableField {
    pub name: String,
    pub sql_type: super::sql_type::SqlType,
    pub is_primary_key: bool,
    ///Tokens converted to_string()
    pub default: Option<String>,
    pub is_not_null: bool,
    pub foreign_key: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TableDataVersion {
    pub table_name: String,
    pub fields: Vec<TableField>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TableData {
    pub saved_versions: HashMap<u64, TableDataVersion>,
    pub latest_version: u64,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct CompilationData {
    ///Key - table id, generated by build macro, put in #[sql(unique_id = "...")] attribute on struct
    pub tables: HashMap<String, TableData>,
}
#[always_context]
impl CompilationData {
    pub fn load() -> anyhow::Result<CompilationData> {
        let current_dir = std::env::current_dir()?;

        let data_path = current_dir.join("easy_sql.ron");

        if !data_path.exists() {
            anyhow::bail!(
                "`easy_lib::sql::build` in build script is required (for automatic migrations and checks); easy_sql.ron file not found in the project directory: {:?}",
                current_dir
            );
        }

        let data =
            std::fs::read_to_string(&data_path).context("Failed to read easy_sql.ron file")?;

        let data: CompilationData =
            ron::de::from_str(&data).context("Failed to parse easy_sql.ron file")?;

        Ok(data)
    }

    #[cfg(feature = "build")]
    pub fn save(&self) -> anyhow::Result<()> {
        let current_dir = std::env::current_dir()?;

        let data_path = current_dir.join("easy_sql.ron");

        let data =
            ron::ser::to_string_pretty(self, ron::ser::PrettyConfig::new().struct_names(true))?;

        std::fs::write(&data_path, &data).context("Failed to write easy_sql.ron file")?;

        Ok(())
    }

    pub fn generate_unique_id(&self) -> String {
        let mut generated = uuid::Uuid::new_v4().to_string();
        let mut exists = true;

        while exists {
            exists = false;
            for unique_id in self.tables.keys() {
                if unique_id == &generated {
                    exists = true;
                    generated = uuid::Uuid::new_v4().to_string();
                    break;
                }
            }
        }
        generated
    }

    pub fn is_duplicate_table_name(
        &self,
        current_unique_id: &str,
        table_name: &str,
    ) -> anyhow::Result<bool> {
        if table_name == "easy_sql_tables" {
            return Ok(true);
        }
        for (unique_id, table_data) in self.tables.iter() {
            if unique_id == current_unique_id {
                continue;
            }
            let latest_version_data =
                match table_data.saved_versions.get(&table_data.latest_version) {
                    Some(o) => o,
                    None => anyhow::bail!(
                        "Table data not found for latest version: {} | unique id: {:?}",
                        table_data.latest_version,
                        unique_id
                    ),
                };

            if latest_version_data.table_name == table_name {
                return Ok(true);
            }
        }

        Ok(false)
    }

    // pub fn generate_migrations(
    //     &self,
}

//TODO Check for table removal inside of build script

//In sqlite you can only add new columns and rename old ones
//(without recreating a table https://www.sqlitetutorial.net/sqlite-alter-table/ )
