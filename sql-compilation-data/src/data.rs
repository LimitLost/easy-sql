use std::{
    collections::{BTreeMap, HashMap},
    path::PathBuf,
    str::FromStr,
};

use anyhow::{self, Context};
use proc_macro2::TokenStream;
use quote::{ToTokens, quote};

use easy_macros::{
    helpers::{TokensBuilder, token_stream_to_consistent_string},
    macros::{always_context, get_attributes, has_attributes},
};
use serde::{Deserialize, Serialize, Serializer};

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
pub struct TableField {
    pub name: String,
    #[serde(default)]
    pub ty_to_bytes: bool,
    pub field_type: String,
    ///Tokens converted to_string()
    pub default: Option<String>,
    pub is_unique: bool,
}
#[derive(Debug, Serialize, Deserialize, Eq, PartialEq)]
pub struct TableDataVersion {
    pub table_name: String,
    pub fields: Vec<TableField>,
    pub primary_keys: Vec<String>,
    pub auto_increment: bool,
    ///key - table (struct) name
    ///value - current field name
    #[serde(serialize_with = "ordered_map")]
    pub foreign_keys: HashMap<String, Vec<String>>,
}

fn ordered_map<S, K: Ord + Serialize, V: Serialize>(
    value: &HashMap<K, V>,
    serializer: S,
) -> Result<S::Ok, S::Error>
where
    S: Serializer,
{
    let ordered: BTreeMap<_, _> = value.iter().collect();
    ordered.serialize(serializer)
}

impl TableDataVersion {
    pub fn from_struct(item: &syn::ItemStruct, table_name: String) -> anyhow::Result<Self> {
        let fields = match &item.fields {
            syn::Fields::Named(fields_named) => &fields_named.named,
            _ => {
                anyhow::bail!(
                    "non named field type should be handled before `generate_table_data_from_struct` is called"
                )
            }
        };

        let mut fields_converted = Vec::new();
        let mut primary_keys = Vec::new();
        let mut foreign_keys = HashMap::new();

        let mut auto_increment = false;

        for field in fields.iter() {
            let name = field.ident.as_ref().unwrap().to_string();

            //Auto Increment Check
            if has_attributes!(field, #[sql(auto_increment)]) {
                if auto_increment {
                    anyhow::bail!("Auto increment is only supported for single primary key");
                }
                auto_increment = true;
            }

            let ty_to_bytes = has_attributes!(field, #[sql(bytes)]);

            let default = get_attributes!(field, #[sql(default = __unknown__)])
                .into_iter()
                .next()
                .map(token_stream_to_consistent_string);

            for foreign_key in get_attributes!(field, #[sql(foreign_key = __unknown__)])
                .into_iter()
                .map(token_stream_to_consistent_string)
            {
                let fields: &mut Vec<String> = foreign_keys
                    .entry(foreign_key)
                    .or_insert(Default::default());
                fields.push(name.clone());
            }

            if has_attributes!(field, #[sql(primary_key)]) {
                primary_keys.push(name.clone());
            }

            let is_unique = has_attributes!(field, #[sql(unique)]);

            fields_converted.push(TableField {
                name,
                field_type: token_stream_to_consistent_string(field.ty.to_token_stream()),
                default,
                is_unique,
                ty_to_bytes,
            });
        }

        Ok(TableDataVersion {
            table_name,
            fields: fields_converted,
            foreign_keys,
            primary_keys,
            auto_increment,
        })
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct TableData {
    #[serde(serialize_with = "ordered_map")]
    pub saved_versions: HashMap<i64, TableDataVersion>,
    pub latest_version: i64,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct CompilationData {
    ///Key - table id, generated by build macro, put in #[sql(unique_id = "...")] attribute on struct
    #[serde(serialize_with = "ordered_map")]
    pub tables: HashMap<String, TableData>,
    #[serde(default)]
    pub default_drivers: Vec<String>,
}
#[always_context]
impl CompilationData {
    pub fn data_location() -> anyhow::Result<PathBuf> {
        let manifest_dir_str = std::env::var("CARGO_MANIFEST_DIR")?;
        let current_dir = PathBuf::from_str(&manifest_dir_str)?;

        Ok(current_dir.join("easy_sql.ron"))
    }
    #[cfg(feature = "build")]
    pub fn load(
        default_drivers: Vec<String>,
        default_drivers_update: bool,
    ) -> anyhow::Result<CompilationData> {
        let data_path = Self::data_location()?;

        let data: CompilationData = {
            #[cfg(feature = "build")]
            {
                if !data_path.exists() {
                    CompilationData {
                        tables: HashMap::new(),
                        default_drivers,
                    }
                } else {
                    let data = std::fs::read_to_string(&data_path)
                        .context("Failed to read easy_sql.ron file")?;

                    let mut data: CompilationData =
                        ron::de::from_str(&data).context("Failed to parse easy_sql.ron file")?;

                    if default_drivers_update && data.default_drivers != default_drivers {
                        data.default_drivers = default_drivers;
                        data.save()?;
                    }

                    data
                }
            }
            #[cfg(not(feature = "build"))]
            {
                if !data_path.exists() {
                    anyhow::bail!(
                        "`easy_sql::build` in build script is required (for automatic migrations and checks); easy_sql.ron file not found in the project directory: {:?}",
                        data_path
                    );
                }

                let data = std::fs::read_to_string(&data_path)
                    .context("Failed to read easy_sql.ron file")?;

                ron::de::from_str(&data).context("Failed to parse easy_sql.ron file")?
            }
        };

        Ok(data)
    }

    #[cfg(feature = "build")]
    pub fn save(&self) -> anyhow::Result<()> {
        let data_path = Self::data_location()?;

        let data =
            ron::ser::to_string_pretty(self, ron::ser::PrettyConfig::new().struct_names(true))?;

        std::fs::write(&data_path, &data).context("Failed to write easy_sql.ron file")?;

        Ok(())
    }

    pub fn generate_unique_id(&self) -> String {
        let mut generated = uuid::Uuid::new_v4().to_string();
        let mut exists = true;

        while exists {
            exists = false;
            for unique_id in self.tables.keys() {
                if unique_id == &generated {
                    exists = true;
                    generated = uuid::Uuid::new_v4().to_string();
                    break;
                }
            }
        }
        generated
    }

    pub fn is_duplicate_table_name(
        &self,
        current_unique_id: &str,
        table_name: &str,
    ) -> anyhow::Result<bool> {
        if table_name == "easy_sql_tables" {
            return Ok(true);
        }
        for (unique_id, table_data) in self.tables.iter() {
            if unique_id == current_unique_id {
                continue;
            }
            let latest_version_data =
                match table_data.saved_versions.get(&table_data.latest_version) {
                    Some(o) => o,
                    None => anyhow::bail!(
                        "Table data not found for latest version: {} | unique id: {:?}",
                        table_data.latest_version,
                        unique_id
                    ),
                };

            if latest_version_data.table_name == table_name {
                return Ok(true);
            }
        }

        Ok(false)
    }

    pub fn generate_migrations(
        &self,
        current_unique_id: &str,
        latest_version: &TableDataVersion,
        latest_version_number: i64,
        sql_crate: &TokenStream,
        item_name: &TokenStream,
    ) -> anyhow::Result<TokenStream> {
        let macro_support = quote! { #sql_crate::macro_support };

        let table_data = self
            .tables
            .get(current_unique_id)
            .context("Table not found in Sql Compilation Data (easy_sql.ron)")?;

        let mut result = TokensBuilder::default();

        for (version_number, version_data) in table_data.saved_versions.iter() {
            let mut changes_needed = Vec::new();

            if version_number == &latest_version_number {
                continue;
            }
            //Primary Key Check (Must be equal)
            if version_data.primary_keys != latest_version.primary_keys {
                anyhow::bail!(
                    "Primary key change is not supported (yet) -> Latest Version: {:?} ||| Version {}: {:?}",
                    latest_version.primary_keys,
                    version_number,
                    version_data.primary_keys
                );
            }
            //Foreign Key Check (Must be equal)
            if version_data.foreign_keys != latest_version.foreign_keys {
                anyhow::bail!(
                    "Foreign key change is not supported (yet) -> Latest Version: {:?} ||| Version {}: {:?}",
                    latest_version.foreign_keys,
                    version_number,
                    version_data.foreign_keys
                );
            }
            //Auto increment check (Must be equal)
            if version_data.auto_increment != latest_version.auto_increment {
                anyhow::bail!(
                    "Auto increment change is not supported (yet) -> Latest Version: {:?} ||| Version {}: {:?}",
                    latest_version.auto_increment,
                    version_number,
                    version_data.auto_increment
                );
            }

            // Table name change support
            if version_data.table_name != latest_version.table_name {
                let new_name = latest_version.table_name.as_str();

                // Rename table
                changes_needed.push(quote! {
                    #sql_crate::AlterTableSingle::RenameTable{
                        new_table_name: #new_name,
                    }
                });
            }

            // Check for old column change
            for (old_field, new_field) in
                version_data.fields.iter().zip(latest_version.fields.iter())
            {
                //We can only rename old columns
                if old_field.name != new_field.name {
                    let old_name = old_field.name.as_str();
                    let new_name = new_field.name.as_str();

                    // Rename field
                    changes_needed.push(quote! {
                        #sql_crate::AlterTableSingle::RenameColumn{
                            old_column_name: #old_name,
                            new_column_name: #new_name,
                        }
                    });
                }
                //Everything else on old column is not supported
                if old_field.field_type != new_field.field_type {
                    anyhow::bail!(
                        "Field type change is not supported (yet) (only rename) -> Latest Version: {:?} ||| Version {}: {:?}",
                        latest_version.fields,
                        version_number,
                        version_data.fields
                    );
                }
                if old_field.is_unique != new_field.is_unique {
                    anyhow::bail!(
                        "Field unique change is not supported (yet) (only rename) -> Latest Version: {:?} ||| Version {}: {:?}",
                        latest_version.fields,
                        version_number,
                        version_data.fields
                    );
                }
                if old_field.default != new_field.default {
                    anyhow::bail!(
                        "Field default value change is not supported (yet) (only rename) -> Latest Version: {:?} ||| Version {}: {:?}",
                        latest_version.fields,
                        version_number,
                        version_data.fields
                    );
                }
            }

            //New Columns Check
            for new_field in latest_version.fields.iter().skip(version_data.fields.len()) {
                //New columns need default value
                if new_field.default.is_none() && !new_field.field_type.starts_with("Option<") {
                    anyhow::bail!(
                        "New (not null) column without default value is not supported -> Latest Version: {:?} ||| Version {}: {:?}",
                        latest_version.fields,
                        version_number,
                        version_data.fields
                    );
                }

                let field_name = new_field.name.as_str();
                let data_type: syn::Type = syn::parse_str(new_field.field_type.as_str())?;
                let is_not_null = !new_field.field_type.starts_with("Option<");
                let is_unique = new_field.is_unique;

                let default_value = if let Some(default_value) = new_field.default.as_deref() {
                    let default_expr: syn::Expr = syn::parse_str(default_value)?;
                    if new_field.ty_to_bytes {
                        let error_context = format!(
                            "Converting default value `{default_value}` to bytes for field `{field_name}`, table_unique_id: `{current_unique_id}` migrating from version: `{version_number}` to version: `{latest_version_number}`",
                        );
                        //For compatibility sake
                        let default_value = default_expr;

                        //Convert provided default value to bytes
                        quote! {
                            {
                                //Test if default value to_bytes will be successful
                                //Even in release mode, just in case, it's low cost anyway
                                #sql_crate::to_bytes(#default_value).context(#error_context)?;

                                #sql_crate::lazy_static!{
                                    static ref DEFAULT_VALUE: #sql_crate::SqlValueMaybeRef<'static> = #sql_crate::to_bytes(#default_value).unwrap().into();
                                }

                                //Check if default value has valid type for the current column
                                #sql_crate::never::never_fn(||{
                                    let mut table_instance = #sql_crate::never::never_any::<#item_name>();
                                    table_instance.#field_name = #default_value;
                                });

                                Some(&*DEFAULT_VALUE)
                            }
                        }
                    } else {
                        //For compatibility sake
                        let default_value = default_expr;

                        quote! {
                            {
                                #sql_crate::lazy_static!{
                                    static ref DEFAULT_VALUE: #sql_crate::SqlValueMaybeRef<'static> = (#default_value).into();
                                }

                                //Check if default value has valid type for the current column
                                #sql_crate::never::never_fn(||{
                                    let mut table_instance = #sql_crate::never::never_any::<#item_name>();
                                    table_instance.#field_name = #default_value;
                                });

                                Some(&*DEFAULT_VALUE)
                            }
                        }
                    }
                } else {
                    quote! {
                        None
                    }
                };

                //Create new field
                changes_needed.push(quote! {
                    #sql_crate::AlterTableSingle::AddColumn{
                        column: #sql_crate::TableField {
                            name: #field_name,
                            data_type: <#data_type as #macro_support::Type<#sql_crate::InternalDriver<D>>>::type_info()
                            .name()
                            .to_owned(),
                            is_unique: #is_unique,
                            is_not_null: #is_not_null,
                            default: #default_value,
                        }
                    }
                });
            }

            //Generate Migration (if needed)
            if !changes_needed.is_empty() {
                let version_number = *version_number;
                let table_name = latest_version.table_name.as_str();

                result.add(quote! {
                    if current_version_number == #version_number{
                        conn.query_setup(#sql_crate::AlterTable{
                            table_name: #table_name,
                            alters: vec![#(#changes_needed),*],
                        }).await?;
                        #sql_crate::EasySqlTables::update_version(conn, #table_name, #latest_version_number).await?;
                        return Ok(());
                    }
                });
            }
        }

        Ok(result.finalize())
    }
}

//TODO Check for table removal inside of build script

//In sqlite you can only add new columns and rename old ones
//(without recreating a table https://www.sqlitetutorial.net/sqlite-alter-table/ )
