use std::collections::HashMap;

use easy_macros::{
    anyhow::{self, Context},
    macros::always_context,
};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct TableField {
    pub name: String,
    pub sql_type: super::sql_type::SqlType,
    pub is_primary_key: bool,
    pub has_default: bool,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TableDataVersion {
    pub table_name: String,
    pub fields: Vec<TableField>,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct TableData {
    pub saved_versions: HashMap<u64, TableDataVersion>,
    pub latest_version: u64,
}
#[derive(Debug, Serialize, Deserialize)]
pub struct CompilationData {
    ///Key - table id, generated by build macro, put in #[sql(unique_id = "...")] attribute on struct
    pub tables: HashMap<String, TableData>,
}
#[always_context]
impl CompilationData {
    pub fn load() -> anyhow::Result<CompilationData> {
        let current_dir = std::env::current_dir()?;

        let data_path = current_dir.join("easy_sql.ron");

        if !data_path.exists() {
            anyhow::bail!(
                "`easy_lib::sql::build` in build script is required (for automatic migrations and checks); easy_sql.ron file not found in the project directory: {:?}",
                current_dir
            );
        }

        let data =
            std::fs::read_to_string(&data_path).context("Failed to read easy_sql.ron file")?;

        let data: CompilationData =
            ron::de::from_str(&data).context("Failed to parse easy_sql.ron file")?;

        Ok(data)
    }

    #[cfg(feature = "build")]
    pub fn save(&self) -> anyhow::Result<()> {
        let current_dir = std::env::current_dir()?;

        let data_path = current_dir.join("easy_sql.ron");

        let data =
            ron::ser::to_string_pretty(self, ron::ser::PrettyConfig::new().struct_names(true))?;

        std::fs::write(&data_path, data).context("Failed to write easy_sql.ron file")?;

        Ok(())
    }

    pub fn generate_unique_id(&self) -> String {
        let mut generated = uuid::Uuid::new_v4().to_string();
        let mut exists = true;

        while exists {
            exists = false;
            for unique_id in self.tables.keys() {
                if unique_id == &generated {
                    exists = true;
                    generated = uuid::Uuid::new_v4().to_string();
                    break;
                }
            }
        }
        generated
    }

    pub fn is_duplicate_table_name(
        &self,
        current_unique_id: &str,
        table_name: &str,
    ) -> anyhow::Result<bool> {
        if table_name == "easy_sql_tables" {
            return Ok(true);
        }
        for (unique_id, table_data) in self.tables.iter() {
            if unique_id == current_unique_id {
                continue;
            }
            let latest_version_data =
                match table_data.saved_versions.get(&table_data.latest_version) {
                    Some(o) => o,
                    None => anyhow::bail!(
                        "Table data not found for latest version: {} | unique id: {:?}",
                        table_data.latest_version,
                        unique_id
                    ),
                };

            if latest_version_data.table_name == table_name {
                return Ok(true);
            }
        }

        Ok(false)
    }

    // pub fn generate_migrations(
    //     &self,
}

#[always_context]
///Returns only type enum variant
fn ty_enum_value(ty: &syn::Type) -> anyhow::Result<(Option<TokenStream>, bool)> {
    match ty {
        syn::Type::Path(type_path) => {
            let mut last_segment = type_path
                .path
                .segments
                .last()
                .with_context(context!("Type path is empty | ty: {:?}", type_path))?;

            let mut name_str = last_segment.ident.to_string();

            let mut not_null = true;

            if name_str == "Option" {
                match &last_segment.arguments {
                    syn::PathArguments::None => {
                        anyhow::bail!("Option with no generic argument is not supported")
                    }
                    syn::PathArguments::AngleBracketed(angle_bracketed_generic_arguments) => {
                        match angle_bracketed_generic_arguments.args.first()? {
                            syn::GenericArgument::Type(ty) => match ty {
                                syn::Type::Path(type_path) => {
                                    last_segment = type_path.path.segments.last().with_context(
                                        context!("Type path is empty | ty: {:?}", type_path),
                                    )?;

                                    name_str = last_segment.ident.to_string();

                                    not_null = false;
                                }
                                _ => anyhow::bail!(
                                    "Option with non- type path generic argument is not supported"
                                ),
                            },
                            _ => anyhow::bail!(
                                "Option with non-type generic argument is not supported"
                            ),
                        }
                    }
                    syn::PathArguments::Parenthesized(_) => {
                        anyhow::bail!(
                            "Option with parenthesized generic arguments is not supported"
                        )
                    }
                }
            }

            let generic_arg = match &last_segment.arguments {
                syn::PathArguments::None => None,
                syn::PathArguments::AngleBracketed(angle_bracketed_generic_arguments) => {
                    angle_bracketed_generic_arguments
                        .args
                        .first()
                        .map(|el| match el {
                            syn::GenericArgument::Type(ty) => match ty {
                                syn::Type::Path(type_path) => type_path
                                    .path
                                    .segments
                                    .last()
                                    .map(|name| name.ident.to_string()),
                                _ => None,
                            },
                            _ => None,
                        })
                        .flatten()
                }
                syn::PathArguments::Parenthesized(_) => None,
            };

            Ok((ty_str_enum_value(&name_str, &generic_arg)?, not_null))
        }
        _ => {
            anyhow::bail!("Unsupported type: {}", ty.to_token_stream())
        }
    }
}

//TODO Check for table removal inside of build script

//In sqlite you can only add new columns and rename old ones
//(without recreating a table https://www.sqlitetutorial.net/sqlite-alter-table/ )
