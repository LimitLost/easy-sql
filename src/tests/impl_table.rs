use async_trait::async_trait;
use easy_macros::macros::always_context;

struct DatabaseSetupTest {
    t: ExampleTable,
}

use crate as sql_crate;
use easy_macros as easy_lib_crate;
use easy_macros::helpers as easy_macros_helpers_crate;

struct ExampleReferencedTable {
    id: i64,
}

#[always_context]
impl sql_crate::SqlTable for ExampleReferencedTable {
    fn table_name() -> &'static str {
        "example_table2"
    }

    fn primary_keys() -> Vec<&'static str> {
        vec!["id"]
    }

    fn table_joins() -> Vec<sql_crate::TableJoin<'static>> {
        vec![]
    }
}

struct ExampleTable {
    id: i64,
    field0: String,
    field1: String,
    field2: i32,
    field3: i64,
    field4: i16,
}

#[always_context]
impl sql_crate::SqlTable for ExampleTable {
    fn table_name() -> &'static str {
        "example_table"
    }

    fn primary_keys() -> Vec<&'static str> {
        vec!["id"]
    }

    fn table_joins() -> Vec<sql_crate::TableJoin<'static>> {
        vec![]
    }
}

#[always_context]
#[async_trait]
impl sql_crate::DatabaseSetup for ExampleTable {
    async fn setup(conn: &mut (impl crate::EasyExecutor + Send + Sync)) -> anyhow::Result<()> {
        use ::anyhow::Context;

        let table_exists = conn
            .query_setup(sql_crate::TableExists {
                name: "example_table",
            })
            .await
            .with_context(easy_macros_helpers_crate::context!(
                "Checking if table exists: {:?}",
                "example_table"
            ))?;

        if table_exists {
            //TODO Get Table Version and migrate (alter table + update version) if neccessary
        } else {
            use sql_crate::EasyExecutor;
            // Create table and create version in EasySqlTables
            conn.query_setup(sql_crate::CreateTable {
                table_name: "example_table",
                fields: vec![sql_crate::TableField {
                    name: "id",
                    data_type: sql_crate::SqlType::I64,
                    is_unique: false,
                    is_not_null: true,
                    default: None,
                }],
                auto_increment: true,
                primary_keys: vec!["id"],
                foreign_keys: {
                    vec![(
                        <ExampleReferencedTable as sql_crate::SqlTable>::table_name(),
                        (
                            vec!["field3"],
                            <ExampleReferencedTable as sql_crate::SqlTable>::primary_keys(),
                            false,
                        ),
                    )]
                    .into_iter()
                    .collect()
                },
            })
            .await?;
            sql_crate::EasySqlTables::create(conn, "table_name".to_string(), 5).await?;
        }

        //If table doesn't exist ( https://stackoverflow.com/questions/1601151/how-do-i-check-in-sqlite-whether-a-table-exists )
        //Save current version to easy_sql_tables table

        //Create Unique id for every table (saved inside of macro file before compilation)
        //Every Unique id is generated by the build.rs

        //Create migrations based on table number change
        //Check if default value was provided by user (if field is not Option<>)

        //TODO In procedural macro
        // save table fields into a file (when the version number attribute changed)

        //In sqlite you can only add new columns and rename old ones
        //(without recreating a table https://www.sqlitetutorial.net/sqlite-alter-table/ )

        Ok(())
    }
}
