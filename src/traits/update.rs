use easy_macros::macros::always_context;

use crate::{Driver, DriverArguments, QueryBuilder, SqlExpr};
use anyhow::Context;

#[always_context]
pub trait Update<'a, Table, D: Driver>: Sized {
    fn updates(self, builder: &mut QueryBuilder<'_, D>) -> anyhow::Result<Vec<(String, SqlExpr)>>;

    fn updates_sqlx(
        self,
        args_list: DriverArguments<'a, D>,
        current_query: &mut String,
        parameter_n: &mut usize,
    ) -> anyhow::Result<DriverArguments<'a, D>>;
}

#[always_context]
impl<'a, F, Table, D: Driver> Update<'a, Table, D> for (Vec<(String, SqlExpr)>, F)
where
    F: Fn(&mut QueryBuilder<'_, D>) -> anyhow::Result<()>,
{
    fn updates(self, builder: &mut QueryBuilder<'_, D>) -> anyhow::Result<Vec<(String, SqlExpr)>> {
        let (updates, bindings_apply) = self;

        (bindings_apply)(
            #[context(no)]
            builder,
        )?;

        Ok(updates)
    }

    fn updates_sqlx(
        self,
        _args_list: DriverArguments<'a, D>,
        _current_query: &mut String,
        _parameter_n: &mut usize,
    ) -> anyhow::Result<DriverArguments<'a, D>> {
        panic!(
            "This method is not generated by the sql! macro, since it shouldn't be used inside of sql_full! macro update clause. Put insides of this macro as the update clause instead."
        );
    }
}
